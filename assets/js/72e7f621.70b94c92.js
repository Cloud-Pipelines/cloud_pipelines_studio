"use strict";(self.webpackChunktangle_website=self.webpackChunktangle_website||[]).push([[8495],{503:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/DataFlow_Files-9a38156b5e4cff9a859daf8ff6e60113.png"},1470:(e,t,n)=>{n.d(t,{A:()=>w});var a=n(6540),s=n(4164),r=n(3104),o=n(6347),i=n(205),l=n(7485),d=n(1682),c=n(679);function u(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,a.useMemo)(()=>{const e=t??function(e){return u(e).map(({props:{value:e,label:t,attributes:n,default:a}})=>({value:e,label:t,attributes:n,default:a}))}(n);return function(e){const t=(0,d.XI)(e,(e,t)=>e.value===t.value);if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[t,n])}function p({value:e,tabValues:t}){return t.some(t=>t.value===e)}function m({queryString:e=!1,groupId:t}){const n=(0,o.W6)(),s=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l.aZ)(s),(0,a.useCallback)(e=>{if(!s)return;const t=new URLSearchParams(n.location.search);t.set(s,e),n.replace({...n.location,search:t.toString()})},[s,n])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:s}=e,r=h(e),[o,l]=(0,a.useState)(()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find(e=>e.default)??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r})),[d,u]=m({queryString:n,groupId:s}),[g,f]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,s]=(0,c.Dv)(t);return[n,(0,a.useCallback)(e=>{t&&s.set(e)},[t,s])]}({groupId:s}),x=(()=>{const e=d??g;return p({value:e,tabValues:r})?e:null})();(0,i.A)(()=>{x&&l(x)},[x]);return{selectedValue:o,selectValue:(0,a.useCallback)(e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)},[u,f,r]),tabValues:r}}var f=n(2303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=n(4848);function b({className:e,block:t,selectedValue:n,selectValue:a,tabValues:o}){const i=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),d=e=>{const t=e.currentTarget,s=i.indexOf(t),r=o[s].value;r!==n&&(l(t),a(r))},c=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=i.indexOf(e.currentTarget)+1;t=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(e.currentTarget)-1;t=i[n]??i[i.length-1];break}}t?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},e),children:o.map(({value:e,label:t,attributes:a})=>(0,y.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{i.push(e)},onKeyDown:c,onClick:d,...a,className:(0,s.A)("tabs__item",x.tabItem,a?.className,{"tabs__item--active":n===e}),children:t??e},e))})}function j({lazy:e,children:t,selectedValue:n}){const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===n);return e?(0,a.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:r.map((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))})}function v(e){const t=g(e);return(0,y.jsxs)("div",{className:(0,s.A)("tabs-container",x.tabList),children:[(0,y.jsx)(b,{...t,...e}),(0,y.jsx)(j,{...t,...e})]})}function w(e){const t=(0,f.A)();return(0,y.jsx)(v,{...e,children:u(e.children)},String(t))}},5146:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"core-concepts/understanding-inputs-outputs","title":"Inputs, Outputs and Data Flow","description":"Understanding how data flows between components is fundamental to building effective pipelines in TangleML. This guide explains the low-level mechanics of inputs, outputs, and data passing between tasks.","source":"@site/docs/core-concepts/understanding-inputs-outputs.mdx","sourceDirName":"core-concepts","slug":"/core-concepts/understanding-inputs-outputs","permalink":"/docs/core-concepts/understanding-inputs-outputs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"understanding-inputs-outputs","title":"Inputs, Outputs and Data Flow"},"sidebar":"docs","previous":{"title":"What are Components?","permalink":"/docs/core-concepts/what-are-components"},"next":{"title":"Caching","permalink":"/docs/core-concepts/caching"}}');var s=n(4848),r=n(8453),o=n(1470),i=n(9365);const l={id:"understanding-inputs-outputs",title:"Inputs, Outputs and Data Flow"},d="Inputs, Outputs and Data Flow",c={},u=[{value:"How Data Actually Flows",id:"how-data-actually-flows",level:2},{value:"Input and Output Types",id:"input-and-output-types",level:2},{value:"Type Conversions and Edge Cases",id:"type-conversions-and-edge-cases",level:2},{value:"Troubleshooting Data Flow Issues",id:"troubleshooting-data-flow-issues",level:2},{value:"Common Errors and Solutions",id:"common-errors-and-solutions",level:3},{value:"Debugging Data Transfer",id:"debugging-data-transfer",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"inputs-outputs-and-data-flow",children:"Inputs, Outputs and Data Flow"})}),"\n",(0,s.jsx)(t.p,{children:"Understanding how data flows between components is fundamental to building effective pipelines in TangleML. This guide explains the low-level mechanics of inputs, outputs, and data passing between tasks."}),"\n",(0,s.jsx)("img",{src:n(9914).A,alt:"Data Flow"}),"\n",(0,s.jsx)(t.h2,{id:"how-data-actually-flows",children:"How Data Actually Flows"}),"\n",(0,s.jsxs)(t.p,{children:["Unlike systems like Airflow (Python classes) or Ray (Python functions), TangleML components are ",(0,s.jsx)(t.strong,{children:"command-line interface (CLI) programs"}),".\nThat means, that in a Pipeline, every task can be executed on different machines, at different times.\nSo passing objects, like in a regular function call, is not possible.\nInstead all inputs are converted to command line arguments and outputs are stored to files.\nSome input values may be safely passed as command line arguments, while other input values may need to be passed as file paths."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"Not all data can be passed/received as a simple string. Examples: binary data, large data, directories.\nIn all these cases, the code should read data from a file or directory pointed to by a path."})}),"\n",(0,s.jsx)(t.p,{children:"When components exchange data in TangleML:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Producer component"})," writes data to a local file path provided by TangleML as arguments to the command line invocation."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"System"})," handles storage transparently (uploads to Google Cloud Storage, S3, etc.)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Consumer component"})," reads from a local file path provided by TangleML as arguments to the command line invocation."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"System"})," handles retrieval transparently (mounts or downloads from storage)"]}),"\n"]}),"\n",(0,s.jsx)("img",{src:n(503).A,alt:"Data Flow"}),"\n",(0,s.jsx)(t.p,{children:"In TangleML, components always work with data using local file paths, so they never need to worry about where the data is actually stored.\nThe underlying storage could be Google Cloud Storage, Amazon S3, or anything else - the details are completely hidden from the component code.\nIdeally, TangleML mounts input artifacts as read-only disks and connects output locations directly to the running container.\nThis means a component simply reads and writes to local paths, and the system streams data straight to and from the global artifact storage.\nIf mounting isn't possible, TangleML takes care of downloading the needed input files before starting the component and uploads any outputs afterward.\nNo matter which approach is used, the component's code only ever sees and works with local files."}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"Components should never hardcode output paths. Always use the paths provided by TangleML through output placeholders."})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(i.A,{value:"python",label:"Python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"def filter_text(\n    text_path: InputPath(),\n    filtered_text_path: OutputPath(),\n    pattern: str,\n):\n    import re\n    with open(text_path, 'r') as reader:\n        with open(filtered_text_path, 'w') as writer:\n            for line in reader:\n                if re.search(pattern, line):\n                    writer.write(line)\n"})})}),(0,s.jsx)(i.A,{value:"shell",label:"Shell",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'  ext_path=$0\n  pattern=$1\n  filtered_text_path=$2\n  mkdir -p "$(dirname "$filtered_text_path")"\n\n  grep "$pattern" < "$text_path" > "$filtered_text_path"\n'})})})]}),"\n",(0,s.jsx)(t.h2,{id:"input-and-output-types",children:"Input and Output Types"}),"\n",(0,s.jsx)(t.p,{children:"From the system's low-level perspective, there are no types; everything is treated as blobs or directories.\nTypes in component specifications are primarily for human understanding and tooling (e.g., Python type checking, visual editors)"}),"\n",(0,s.jsxs)(t.p,{children:["Inputs may be defined as ",(0,s.jsx)(t.a,{href:"/docs/reference/schema#inputvalueplaceholder",children:"InputValue"})," or ",(0,s.jsx)(t.a,{href:"/docs/reference/schema#inputpathplaceholder",children:"InputPath"}),".\nInputValue is suitable for small values that can be passed as command line arguments. InputPath is suitable for large values that need to be passed as file paths."]}),"\n",(0,s.jsxs)(t.p,{children:["Outputs are always defined as ",(0,s.jsx)(t.a,{href:"/docs/reference/schema#outputpathplaceholder",children:"OutputPath"}),"."]}),"\n",(0,s.jsx)(t.admonition,{title:"Why no OutputValue?",type:"tip",children:(0,s.jsx)(t.p,{children:"CLI programs don't have a standard way to return values. They can only write to files, directories, or stdout (which can be redirected to a file)."})}),"\n",(0,s.jsxs)(t.p,{children:['Unlike some systems (Vertex AI, KFP v2) that separate "parameters" (constants) from "artifacts" (connected data), TangleML has ',(0,s.jsx)(t.strong,{children:"one unified input system"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"# TangleML: Any input can receive any source\ninputs:\n  - name: threshold\n    type: Float\n    # Can receive:\n    # - Constant: {value: 0.5}\n    # - Task output: {taskOutput: optimizer.best_threshold}\n    # - Graph input: {graphInput: user_threshold}\n\n  - name: data\n    type: Dataset\n    # Same flexibility for all inputs!\n"})}),"\n",(0,s.jsx)(t.admonition,{title:"Systems with Separated Inputs",type:"warning",children:(0,s.jsx)(t.p,{children:'In Vertex/KFP v2, you must decide at component creation whether an input is a "parameter" (constant only) or "artifact" (connection only). This causes friction when you need to change how data flows.'})}),"\n",(0,s.jsx)(t.p,{children:"Unified inputs offer several practical advantages for users.\nThey provide flexibility, allowing you to switch between hardcoded values and dynamic, data-driven ones without needing to change how your components are written.\nThis simplifies experimentation, making it easy to run hyperparameter tuning or try out different configurations.\nAdditionally, debugging becomes more convenient\u2014you can quickly test components by substituting outputs with simple test constants as needed."}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.mdxAdmonitionTitle,{}),(0,s.jsx)(t.p,{children:"To convert inputs into a proper data types, components must parse input values or read input files with appropriate language-specific tools."})]}),"\n",(0,s.jsx)(t.h2,{id:"type-conversions-and-edge-cases",children:"Type Conversions and Edge Cases"}),"\n",(0,s.jsx)(t.p,{children:"What happens when you connect an output to an incompatible input? The launcher handles conversions automatically:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Scenario"}),(0,s.jsx)(t.th,{children:"What Happens"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"Output \u2192 InputValue"})}),(0,s.jsx)(t.td,{children:"Launcher downloads artifact, converts to string (if small enough)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"Constant \u2192 InputPath"})}),(0,s.jsx)(t.td,{children:"Launcher uploads value to staging area, provides path"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"Large artifact \u2192 InputValue"})}),(0,s.jsx)(t.td,{children:'System error: "Artifact too big to consume as value"'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"Directory \u2192 InputValue"})}),(0,s.jsx)(t.td,{children:"System error: Cannot convert directory to string"})]})]})]}),"\n",(0,s.jsxs)(t.admonition,{type:"warning",children:[(0,s.jsxs)(t.p,{children:["When connecting an output to an InputValue input, the TangleML will attempt to read the content of the artifact and convert it to a string.\nIf the artifact is large, the launcher will return an error: ",(0,s.jsx)(t.code,{children:"Artifact is too big to consume as value. Consume it as file instead. input_name='Format'"})]}),(0,s.jsx)("img",{src:n(7235).A,alt:"Type Conversion"})]}),"\n",(0,s.jsx)(t.h2,{id:"troubleshooting-data-flow-issues",children:"Troubleshooting Data Flow Issues"}),"\n",(0,s.jsx)(t.h3,{id:"common-errors-and-solutions",children:"Common Errors and Solutions"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Error"}),(0,s.jsx)(t.th,{children:"Cause"}),(0,s.jsx)(t.th,{children:"Solution"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:'"Artifact too big to consume as value"'})}),(0,s.jsx)(t.td,{children:"Output connected to InputValue, but data > threshold"}),(0,s.jsx)(t.td,{children:"Use InputPath instead or reduce data size"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:'"Cannot convert directory to string"'})}),(0,s.jsx)(t.td,{children:"Directory output connected to InputValue"}),(0,s.jsx)(t.td,{children:"Component must accept InputPath for directories"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"404 on artifact URL"})}),(0,s.jsx)(t.td,{children:"Artifact older than TTL (30 days)"}),(0,s.jsx)(t.td,{children:"Re-run pipeline or check metadata (size, hash still available)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:'"No such file or directory"'})}),(0,s.jsx)(t.td,{children:"Hardcoded paths instead of placeholders"}),(0,s.jsxs)(t.td,{children:["Use OutputPath placeholders: ",(0,s.jsx)(t.code,{children:"{OutputPath: model}"})]})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"debugging-data-transfer",children:"Debugging Data Transfer"}),"\n",(0,s.jsx)(t.p,{children:"To debug data flow issues:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Check artifact sizes"})," in the UI - Large size changes indicate problems"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Verify artifact types"})," - Ensure blob vs directory matches expectations"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Review launcher logs"})," - Shows mounting/downloading operations"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Test locally first"})," - Use local Docker to verify component I/O"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},7235:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/DataFlow_IncorrectConnection-40c91757a7bca5316e60cf3387cbf903.png"},9365:(e,t,n)=>{n.d(t,{A:()=>o});n(6540);var a=n(4164);const s={tabItem:"tabItem_Ymn6"};var r=n(4848);function o({children:e,hidden:t,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)(s.tabItem,n),hidden:t,children:e})}},9914:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/PipelineRun-02605ccb0d76d18eca3fa13a16386e97.png"}}]);