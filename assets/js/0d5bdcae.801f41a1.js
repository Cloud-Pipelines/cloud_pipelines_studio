"use strict";(self.webpackChunktangle_website=self.webpackChunktangle_website||[]).push([[3315],{2018:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/CreatingComponent_Details-92981eca4cf974d7b4b87e5bea9cb70d.png"},4110:(e,n,t)=>{t.d(n,{v:()=>i});var a=t(4848);const i=({src:e,alt:n,children:t})=>(0,a.jsx)("div",{children:(0,a.jsxs)("div",{style:{display:"flex",flexDirection:"row",gap:"4em",width:"100%",justifyContent:"flex-start",alignContent:"flex-start"},children:[(0,a.jsx)("div",{style:{width:"fit-content"},children:(0,a.jsx)("img",{src:e,alt:n,style:{width:"250px",borderRadius:"6px"}})}),(0,a.jsx)("div",{children:t})]})})},6093:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/medias/CreatingComponent_Running-cfd82e0ea558ffab6d201b0416495a75.mov"},6974:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"component-development/creating-components","title":"Lightweight Python Components","description":"For Python developers, TangleML offers a special feature - lightweight component generation. It is supported by the Oasis CLI tool.","source":"@site/docs/component-development/creating-components.mdx","sourceDirName":"component-development","slug":"/component-development/creating-components","permalink":"/docs/component-development/creating-components","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"creating-components","title":"Lightweight Python Components"},"sidebar":"docs","previous":{"title":"Caching","permalink":"/docs/core-concepts/caching"},"next":{"title":"In-App Component Editor","permalink":"/docs/component-development/in-app-editor"}}');var i=t(4848),r=t(8453);t(4110);const o={id:"creating-components",title:"Lightweight Python Components"},s=void 0,l={},p=[{value:"Lightweight Python Components",id:"lightweight-python-components",level:2},{value:"The <code>InputPath</code> and <code>OutputPath</code> annotations",id:"the-inputpath-and-outputpath-annotations",level:3},{value:"Why do we need the <code>InputPath</code> parameter annotation?",id:"why-do-we-need-the-inputpath-parameter-annotation",level:3},{value:"Default parameter values",id:"default-parameter-values",level:3},{value:"Input and Output Types",id:"input-and-output-types",level:3},{value:"Tutorial: Creating a Lightweight Python Component",id:"tutorial-creating-a-lightweight-python-component",level:2},{value:"Step 1: Create the Component Function",id:"step-1-create-the-component-function",level:3},{value:"Step 2: Generate the Component Specification",id:"step-2-generate-the-component-specification",level:3},{value:"Step 3: Running the Component",id:"step-3-running-the-component",level:3},{value:"Appendix",id:"appendix",level:2},{value:"Sample Data",id:"sample-data",level:3},{value:"Common Regex Patterns",id:"common-regex-patterns",level:3},{value:"Regex Flags Reference",id:"regex-flags-reference",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components},{Details:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["For Python developers, TangleML offers a special feature - ",(0,i.jsx)(n.strong,{children:"lightweight component generation"}),". It is supported by the Oasis CLI tool."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Learn more about the Oasis CLI tool in the ",(0,i.jsx)(n.a,{href:"/docs/component-development/oasis-cli-manual",children:"Oasis CLI Manual"})," section."]})}),"\n",(0,i.jsx)(n.h2,{id:"lightweight-python-components",children:"Lightweight Python Components"}),"\n",(0,i.jsxs)(n.p,{children:["Instead of rebuilding containers for every code change, the Python code goes ",(0,i.jsx)(n.strong,{children:"in the command line"}),", outside the container:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'implementation:\n  container:\n    image: python:3.9 # Use official image, no custom build!\n    command: ["python", "-c"]\n    args:\n      - |\n        def train_model(data_path: str, epochs: int = 10):\n            # Your Python code here\n            return model_path\n        # Generated wrapper code handles I/O\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"the-inputpath-and-outputpath-annotations",children:["The ",(0,i.jsx)(n.code,{children:"InputPath"})," and ",(0,i.jsx)(n.code,{children:"OutputPath"})," annotations"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"text_path: InputPath()"})," annotation tells the system that the input data for the text input should be placed into some file and the path of that file should be given to the function as a value for the text_path function parameter."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"filtered_text_path: OutputPath()"})," annotation tells the system that it should generate and give the function a path (via the filtered_text_path parameter) where the function should write the output data. After the function finishes the execution, the system will take the output data written by the function, put it into storage and make it available for passing to other components."]}),"\n",(0,i.jsxs)(n.h3,{id:"why-do-we-need-the-inputpath-parameter-annotation",children:["Why do we need the ",(0,i.jsx)(n.code,{children:"InputPath"})," parameter annotation?"]}),"\n",(0,i.jsx)(n.p,{children:"Not all data can be passed/received as a simple string. Examples: binary data, large data, directories. In all these cases, the code should read data from a file or directory pointed to by a path. This is why we have a text_path: InputPath() parameter and not text: str parameter (although the latter could still work for short texts). Another reason why the InputPath annotation is needed is that the component function code is executed inside a hermetic container. The text file needs to somehow be placed inside the container. Only the system can do that. The text_path: InputPath() annotation tells the system that the input data for the text input should be placed into some file and the path of that file should be given to the function as a value for the text_path function parameter."}),"\n",(0,i.jsx)(n.p,{children:"Similarly the filtered_text_path: OutputPath() parameter annotation is needed so that the system knows that it needs to get the output data out of the container when the function finishes its execution."}),"\n",(0,i.jsx)(n.h3,{id:"default-parameter-values",children:"Default parameter values"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"create_component_from_func"})," function supports functions with default parameter values. This results in the generated component inputs becoming optional."]}),"\n",(0,i.jsxs)(n.p,{children:["Path parameters annotated with ",(0,i.jsx)(n.code,{children:"InputPath()"})," can have a default value of ",(0,i.jsx)(n.code,{children:"None"})," which makes those file inputs optional."]}),"\n",(0,i.jsx)(n.p,{children:"The default parameter values can use any Python built-in type. (Only the built-in types can be used because the function needs to remain self-contained)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def some_func(\n    some_int: int = 3,\n    some_path: InputPath() = None,\n):\n    from pathlib import Path\n    if some_path:\n        Path(some_path).read_text()\n    ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-types",children:"Input and Output Types"}),"\n",(0,i.jsxs)(n.p,{children:["While low-level TangleML does not enforce any types, the Oasis CLI generator (",(0,i.jsx)(n.code,{children:"components.create_component_from_func"}),") provides support for six basic Python types:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Python Type"}),(0,i.jsx)(n.th,{children:"TangleML Type"}),(0,i.jsx)(n.th,{children:"Serialization"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"str"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:"Direct passing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Integer"})}),(0,i.jsx)(n.td,{children:"String to int conversion"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"float"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Float"})}),(0,i.jsx)(n.td,{children:"String to float conversion"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Boolean"})}),(0,i.jsx)(n.td,{children:"String to boolean conversion"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JsonArray"})}),(0,i.jsx)(n.td,{children:"JSON serialization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"dict"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JsonObject"})}),(0,i.jsx)(n.td,{children:"JSON serialization"})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Beyond the Basics"}),": You can use any type annotation (like ",(0,i.jsx)(n.code,{children:"XGBoostModel"}),"), but unsupported types will be passed as strings. The generator only adds serialization/deserialization for the six basic types."]})}),"\n",(0,i.jsx)(n.p,{children:"The function parameters (the parameter names and type annotations) are mapped to component inputs and outputs in a certain way. This example demonstrates all aspects of the mapping"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def my_func(\n    # Directly supported types:\n    # Mapped to input with name "some_string" and type "String"\n    some_string: str,\n    # Mapped to input with name "some_string" and type "Integer"\n    some_integer: int,\n    # Mapped to input with name "some_float" and type "Float"\n    some_float: float,\n    # Mapped to input with name "some_boolean" and type "Boolean"\n    some_boolean: bool,\n    # Mapped to input with name "some_list" and type "JsonArray"\n    some_list: list,\n    # Mapped to input with name "some_dict" and type "JsonObject"\n    some_dict: dict,\n\n    # Mapped to input with name "any_thing" and no type (compatible with any type. Will receive a string value at runtime!)\n    any_thing,\n\n    # Other types\n    # Mapped to input with name "some_uri" and type "Uri" (Will receive a string value at runtime!)\n    some_uri: "Uri",\n    # Mapped to input with name "some_uri" and type "BigInt" (Will receive a string value at runtime!)\n    some_uri: BigInt,\n\n    # Paths:\n    # Mapped to input with name "input1" (the "_path" suffix is removed)\n    input1_path: InputPath(""),\n    # Mapped to output with name "output1" and type "CSV" (the "_path" suffix is removed)\n    output1_path: OutputPath("CSV"),\n) -> typing.NamedTuple("Outputs", [\n    # Mapped to output with name "output_string" and type "String"\n    ("output_string", str),\n    # Mapped to output with name "output_uri" and type "Uri" (function needs to return a string)\n    ("output_uri", "Uri"),\n]):\n    ...\n    return ("Some string", "some-uri://...")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"tutorial-creating-a-lightweight-python-component",children:"Tutorial: Creating a Lightweight Python Component"}),"\n",(0,i.jsx)(n.p,{children:"This guide walks you through creating a TangleML component that performs regex-based text replacement. The component reads an input text file, replaces all substrings matching a given regex pattern, and writes the result to an output file."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["To learn more about Components in TangleML, check the ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/what-are-components",children:"Component Architecture"})," page."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-1-create-the-component-function",children:"Step 1: Create the Component Function"}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["You may use a ",(0,i.jsx)(n.a,{href:"/docs/component-development/oasis-cli-manual#quick-start",children:"quick start"})," from the Oasis CLI Manual."]})}),"\n",(0,i.jsxs)(n.p,{children:["Create a file named ",(0,i.jsx)(n.code,{children:"regex_replace.py"}),". The file should contain the following code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from cloud_pipelines import components\nfrom typing import Optional\n\n\ndef regex_replace(\n    input_text_path: components.InputPath(),\n    output_text_path: components.OutputPath(),\n    pattern: str,\n    replacement: str,\n    flags: Optional[int] = 0,\n    count: int = 0,\n):\n    # All imports must be inside the function for Cloud Pipelines compatibility\n    import re\n\n    # Read the input file\n    with open(input_text_path, 'r') as input_file:\n        content = input_file.read()\n\n    # Perform regex replacement\n    result = re.sub(\n        pattern=pattern,\n        repl=replacement,\n        string=content,\n        count=count,\n        flags=flags\n    )\n\n    # Write the result to the output file\n    with open(output_text_path, 'w') as output_file:\n        output_file.write(result)\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:"It is very usefull to add logging to your component."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'\n    # Log operation details for debugging\n    import logging\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n\n    # Count matches for reporting\n    matches = re.findall(pattern, content, flags=flags)\n    num_matches = len(matches)\n\n    logger.info(f"Regex pattern: {pattern}")\n    logger.info(f"Replacement: {replacement}")\n    logger.info(f"Total matches found: {num_matches}")\n    logger.info(f"Replacements made: {min(num_matches if count == 0 else count, num_matches)}")\n'})})]}),"\n",(0,i.jsxs)(n.p,{children:["All imports, such as ",(0,i.jsx)(n.code,{children:"re"})," and ",(0,i.jsx)(n.code,{children:"logging"}),", are placed inside the function.\nThere are no external dependencies on code outside the function.\nThis design makes sure the function can be containerized properly."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"InputPath()"})," annotation tells TangleML to provide a file path for your input data.\nThe ",(0,i.jsx)(n.code,{children:"OutputPath()"})," annotation tells TangleML where your output data should be written."]}),"\n",(0,i.jsxs)(n.p,{children:["These path annotations automatically handle data transfer between different pipeline components.\nThe function requires ",(0,i.jsx)(n.code,{children:"pattern"})," and ",(0,i.jsx)(n.code,{children:"replacement"})," parameters as strings.\nIt also includes optional parameters, like ",(0,i.jsx)(n.code,{children:"flags"})," and ",(0,i.jsx)(n.code,{children:"count"}),", which have default values.\nUsing proper type annotations helps generate the correct component interface."]}),"\n",(0,i.jsx)(n.p,{children:"There is one missing piece of information: the component name and description.\nAdd the following metadata to the file immediately after the function definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def regex_replace(\n    input_text_path: components.InputPath(),\n    output_text_path: components.OutputPath(),\n    pattern: str,\n    replacement: str,\n    flags: Optional[int] = 0,\n    count: int = 0,\n):\n    """\n    Replace substrings matching a regex pattern in a text file.\n\n    Args:\n        input_text_path: Path to the input text file\n        output_text_path: Path where the output text file will be written\n        pattern: Regular expression pattern to search for\n        replacement: String to replace matched patterns with\n        flags: Optional regex flags (e.g., re.IGNORECASE = 2, re.MULTILINE = 8)\n        count: Maximum number of replacements per line (0 means replace all)\n    """\n'})}),"\n",(0,i.jsx)(n.p,{children:"This notation is used by the Oasis CLI tool to generate the proper component specification, including the component name and description, inputs and outputs inlined documentation."}),"\n",(0,i.jsx)("img",{src:t(2018).A,alt:"Metadata",style:{width:"50%",borderRadius:"6px"}}),"\n",(0,i.jsx)(n.h3,{id:"step-2-generate-the-component-specification",children:"Step 2: Generate the Component Specification"}),"\n",(0,i.jsx)(n.p,{children:"Run the command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'PYTHONPATH=$PWD uvx --refresh --from git+https://github.com/Cloud-Pipelines/oasis-cli.git@stable \\\n      oasis components regenerate python-function-component \\\n      --output-component-yaml-path "regex_replace.component.yaml" \\\n      --module-path="regex_replace.py" \\\n      --function-name "regex_replace"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This generates ",(0,i.jsx)(n.code,{children:"regex_replace_component.yaml"})," containing the component specification."]}),"\n",(0,i.jsxs)(a,{children:[(0,i.jsx)("summary",{children:"regex_replace_component.yaml"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'name: Regex replace\ndescription: Replace substrings matching a regex pattern in a text file.\nmetadata:\n  annotations:\n    cloud_pipelines.net: "true"\n    components new regenerate python-function-component: "true"\n    python_original_code_path: regex_replace.py\n    python_original_code: |\n      """\n      Cloud Pipelines compatible regex replace component function.\n      This function reads text from a file, replaces substrings matching a regex pattern,\n      and writes the result to an output file.\n      """\n\n      from typing import Optional\n      from pipelines.components import InputPath, OutputPath\n\n\n      def regex_replace(\n          input_text_path: InputPath(),\n          output_text_path: OutputPath(),\n          pattern: str,\n          replacement: str,\n          flags: Optional[int] = 0,\n          count: int = 0,\n      ):\n          """\n          Replace substrings matching a regex pattern in a text file.\n\n          Args:\n              input_text_path: Path to the input text file\n              output_text_path: Path where the output text file will be written\n              pattern: Regular expression pattern to search for\n              replacement: String to replace matched patterns with\n              flags: Optional regex flags (e.g., re.IGNORECASE = 2, re.MULTILINE = 8)\n              count: Maximum number of replacements per line (0 means replace all)\n          """\n          # All imports must be inside the function for Cloud Pipelines compatibility\n          import re\n\n          # Read the input file\n          with open(input_text_path, "r") as input_file:\n              content = input_file.read()\n\n          # Perform regex replacement\n          # The re.sub function replaces all occurrences of pattern with replacement\n          result = re.sub(\n              pattern=pattern, repl=replacement, string=content, count=count, flags=flags\n          )\n\n          # Write the result to the output file\n          with open(output_text_path, "w") as output_file:\n              output_file.write(result)\n\n          # Log operation details for debugging\n          import logging\n\n          logging.basicConfig(level=logging.INFO)\n          logger = logging.getLogger(__name__)\n\n          # Count matches for reporting\n          matches = re.findall(pattern, content, flags=flags)\n          num_matches = len(matches)\n\n          logger.info(f"Regex pattern: {pattern}")\n          logger.info(f"Replacement: {replacement}")\n          logger.info(f"Total matches found: {num_matches}")\n          logger.info(\n              f"Replacements made: {min(num_matches if count == 0 else count, num_matches)}"\n          )\n    component_yaml_path: regex_replace.component.yaml\ninputs:\n  - { name: input_text, description: Path to the input text file }\n  - {\n      name: pattern,\n      type: String,\n      description: Regular expression pattern to search\n        for,\n    }\n  - {\n      name: replacement,\n      type: String,\n      description: String to replace matched patterns\n        with,\n    }\n  - {\n      name: flags,\n      type: Integer,\n      description: "Optional regex flags (e.g., re.IGNORECASE\n        = 2, re.MULTILINE = 8)",\n      default: "0",\n      optional: true,\n    }\n  - {\n      name: count,\n      type: Integer,\n      description: Maximum number of replacements per line\n        (0 means replace all),\n      default: "0",\n      optional: true,\n    }\noutputs:\n  - {\n      name: output_text,\n      description: Path where the output text file will be written,\n    }\nimplementation:\n  container:\n    image: python:3.11\n    command:\n      - sh\n      - -ec\n      - |\n        program_path=$(mktemp)\n        printf "%s" "$0" > "$program_path"\n        python3 -u "$program_path" "$@"\n      - |\n        def _make_parent_dirs_and_return_path(file_path: str):\n            import os\n\n            os.makedirs(os.path.dirname(file_path), exist_ok=True)\n            return file_path\n\n        def regex_replace(\n            input_text_path,\n            output_text_path,\n            pattern,\n            replacement,\n            flags = 0,\n            count = 0,\n        ):\n            """\n            Replace substrings matching a regex pattern in a text file.\n\n            Args:\n                input_text_path: Path to the input text file\n                output_text_path: Path where the output text file will be written\n                pattern: Regular expression pattern to search for\n                replacement: String to replace matched patterns with\n                flags: Optional regex flags (e.g., re.IGNORECASE = 2, re.MULTILINE = 8)\n                count: Maximum number of replacements per line (0 means replace all)\n            """\n            # All imports must be inside the function for Cloud Pipelines compatibility\n            import re\n\n            # Read the input file\n            with open(input_text_path, "r") as input_file:\n                content = input_file.read()\n\n            # Perform regex replacement\n            # The re.sub function replaces all occurrences of pattern with replacement\n            result = re.sub(\n                pattern=pattern, repl=replacement, string=content, count=count, flags=flags\n            )\n\n            # Write the result to the output file\n            with open(output_text_path, "w") as output_file:\n                output_file.write(result)\n\n            # Log operation details for debugging\n            import logging\n\n            logging.basicConfig(level=logging.INFO)\n            logger = logging.getLogger(__name__)\n\n            # Count matches for reporting\n            matches = re.findall(pattern, content, flags=flags)\n            num_matches = len(matches)\n\n            logger.info(f"Regex pattern: {pattern}")\n            logger.info(f"Replacement: {replacement}")\n            logger.info(f"Total matches found: {num_matches}")\n            logger.info(\n                f"Replacements made: {min(num_matches if count == 0 else count, num_matches)}"\n            )\n\n        import argparse\n        _parser = argparse.ArgumentParser(prog=\'Regex replace\', description=\'Replace substrings matching a regex pattern in a text file.\')\n        _parser.add_argument("--input-text", dest="input_text_path", type=str, required=True, default=argparse.SUPPRESS)\n        _parser.add_argument("--pattern", dest="pattern", type=str, required=True, default=argparse.SUPPRESS)\n        _parser.add_argument("--replacement", dest="replacement", type=str, required=True, default=argparse.SUPPRESS)\n        _parser.add_argument("--flags", dest="flags", type=int, required=False, default=argparse.SUPPRESS)\n        _parser.add_argument("--count", dest="count", type=int, required=False, default=argparse.SUPPRESS)\n        _parser.add_argument("--output-text", dest="output_text_path", type=_make_parent_dirs_and_return_path, required=True, default=argparse.SUPPRESS)\n        _parsed_args = vars(_parser.parse_args())\n\n        _outputs = regex_replace(**_parsed_args)\n    args:\n      - --input-text\n      - { inputPath: input_text }\n      - --pattern\n      - { inputValue: pattern }\n      - --replacement\n      - { inputValue: replacement }\n      - if:\n          cond: { isPresent: flags }\n          then:\n            - --flags\n            - { inputValue: flags }\n      - if:\n          cond: { isPresent: count }\n          then:\n            - --count\n            - { inputValue: count }\n      - --output-text\n      - { outputPath: output_text }\n'})})]}),"\n",(0,i.jsxs)(n.p,{children:["Notice, that Oasis CLI tool generated additional code to handle component inputs and outputs. Do you still remember, that component in ",(0,i.jsx)(n.a,{href:"/docs/core-concepts/what-are-components",children:"TangleML is just a CLI program"}),"?"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'  import argparse\n  _parser = argparse.ArgumentParser(prog=\'Regex replace\', description=\'Replace substrings matching a regex pattern in a text file.\')\n  _parser.add_argument("--input-text", dest="input_text_path", type=str, required=True, default=argparse.SUPPRESS)\n  _parser.add_argument("--pattern", dest="pattern", type=str, required=True, default=argparse.SUPPRESS)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-running-the-component",children:"Step 3: Running the Component"}),"\n",(0,i.jsx)(n.p,{children:'To use the component, drop it into your pipeline and configure the inputs. Click "Submit Run" to execute the pipeline.'}),"\n",(0,i.jsx)("video",{src:t(6093).A,autoPlay:!0,loop:!0,muted:!0,playsInline:!0,style:{width:"100%"},children:(0,i.jsx)(n.p,{children:"Your browser does not support the video tag."})}),"\n",(0,i.jsx)(n.h2,{id:"appendix",children:"Appendix"}),"\n",(0,i.jsx)(n.h3,{id:"sample-data",children:"Sample Data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-txt",children:"Employee Records - Confidential\n================================\n\nEmployee: John Doe\nEmail: john.doe@company.com\nPhone: (555) 123-4567\nSSN: 123-45-6789\nDepartment: Engineering\n\nEmployee: Jane Smith\nEmail: jane.smith@company.com\nPhone: +1-555-987-6543\nSSN: 987-65-4321\nDepartment: Marketing\n\nSystem Information:\nServer IP: 192.168.1.100\nDatabase IP: 10.0.0.45\nAdmin Email: admin@company.com\n\nPayment Information:\nCustomer: Bob Wilson\nEmail: bob.wilson@email.com\nCredit Card: 4532-1234-5678-9012\nBilling Address: 123 Main St\n\nSupport Tickets:\nTicket #1234\nFrom: customer1@gmail.com\nIssue: Cannot access account from IP 203.0.113.42\n\nTicket #5678\nFrom: support@website.org\nIssue: Payment failed for card ending in 4321\n\nNotes:\n- Contact HR at hr@company.com or call 555-0100\n- Server maintenance scheduled for 192.168.1.200\n- Update payment info for CC: 5432 1098 7654 3210\n"})}),"\n",(0,i.jsx)(n.h3,{id:"common-regex-patterns",children:"Common Regex Patterns"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Pattern"}),(0,i.jsx)(n.th,{children:"Example Replacement"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Email Addresses"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[EMAIL]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Phone Numbers"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[PHONE]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"URLs"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"https?://[^\\s]+"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[URL]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"IP Addresses"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[IP]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Dates (MM/DD/YYYY)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\b\\d{1,2}/\\d{1,2}/\\d{4}\\b"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[DATE]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Credit Cards"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[CC]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Social Security Numbers"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\b\\d{3}-\\d{2}-\\d{4}\\b"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[SSN]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Whitespace Cleanup"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"\\s+"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:" "})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"HTML Tags"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<[^>]+>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:" "})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Code Comments (Python)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"#.*$"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:" "})})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"regex-flags-reference",children:"Regex Flags Reference"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Flag"}),(0,i.jsx)(n.th,{children:"Value"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Use Case"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"re.IGNORECASE"})}),(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"Case-insensitive matching"}),(0,i.jsx)(n.td,{children:'Match "Error", "ERROR", "error"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"re.MULTILINE"})}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"^"})," and ",(0,i.jsx)(n.code,{children:"$"})," match line boundaries"]}),(0,i.jsx)(n.td,{children:"Pattern matching per line"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"re.DOTALL"})}),(0,i.jsx)(n.td,{children:"16"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"."})," matches newlines"]}),(0,i.jsx)(n.td,{children:"Multi-line pattern matching"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"re.VERBOSE"})}),(0,i.jsx)(n.td,{children:"64"}),(0,i.jsx)(n.td,{children:"Ignore whitespace in pattern"}),(0,i.jsx)(n.td,{children:"Complex patterns with comments"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"To combine flags, add their values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"flags = 2 + 8  # IGNORECASE + MULTILINE = 10\n"})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);